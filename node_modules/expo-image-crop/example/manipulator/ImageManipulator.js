import React, { Component } from 'react'
import {
    PanResponder, Dimensions, Image, ScrollView, Modal, View, Text, SafeAreaView
} from 'react-native'
import * as Animatable from 'react-native-animatable'
import { ImageManipulator, FileSystem } from 'expo'
import PropTypes from 'prop-types'
import AutoHeightImage from 'react-native-auto-height-image'
// eslint-disable-next-line import/no-extraneous-dependencies
import Icon from 'react-native-vector-icons/MaterialCommunityIcons'
// eslint-enable-next-line import/no-extraneous-dependencies

import HybridTouch from '../HybridTouch'
import Gestures from 'react-native-easy-gestures';

// https://snack.expo.io/@msand/svg-pinch-to-pan-and-zoom-with-alignment
// explore this for pinch to zoom in one axis

const { width,height } = Dimensions.get('window')

class ImgManipulator extends Component {
    constructor(props) {
        super(props)
        const { photo } = this.props
        this.state = {
            cropMode: false,
            uri: photo.uri,
        }

        this.scrollOffset = 0

        this.currentPos = {
            left: 0,
            top: 0,
        }

        this.currentSize = {
            width: 0,
            height: 0,
        }

        this.maxSizes = {
            width: 0,
            height: 0,
        }

        this.isResizing = false

        this._panResponder = PanResponder.create({
            // Ask to be the responder:
            onStartShouldSetPanResponder: () => true,
            onStartShouldSetPanResponderCapture: () => true,
            onMoveShouldSetPanResponder: () => true,
            onMoveShouldSetPanResponderCapture: () => true,

            onPanResponderGrant: () => {
                this.scrollView.setNativeProps({ scrollEnabled: false })
            },
            onPanResponderMove: (evt, gestureState) => {
                //changed 0.9 -> 1
                if (!this.isResizing && gestureState.x0 < this.currentPos.left + this.currentSize.width * 0.9 && gestureState.y0 < this.currentPos.top + this.currentSize.height * 0.9) {
                    this.square.transitionTo({ left: gestureState.moveX - this.currentSize.width / 2, top: gestureState.moveY + /**this.scrollOffset**/ - this.currentSize.height / 2  /**  OFFSET */ }, 0)
                } else {
                    this.isResizing = true
                    //This place NEEDS MORE WORK
                    //modified here because only need uniform crop
                    // const distance_init = Math.sqrt(Math.pow(gestureState.x0-this.currentPos.left,2)+Math.pow(gestureState.y0-this.currentPos.top,2))
                    // const distance_new = Math.sqrt(Math.pow(gestureState.moveX-this.currentPos.left,2)+Math.pow(gestureState.moveY-this.currentPos.top,2))
                    // const scale = distance_new/distance_init
                    const scale_x = (gestureState.moveX - this.currentPos.left)/this.currentSize.width
                    const scale_y = (gestureState.moveY - this.currentPos.top)/this.currentSize.height
                    let scale = 1
                    scale_x >= 1 || scale_y >= 1 ? scale = Math.max(scale_x,scale_y): scale = Math.min(scale_x,scale_y)
                    scale>=1.2 ? scale = 1.2 : scale = scale
                    scale<=0.8 ? scale = 0.8 : scale = scale
                    // scale = scale > 1.2 ? 
                    // const squareWidth = gestureState.moveX - this.currentPos.left
                    // const squareHeight = gestureState.moveY - this.currentPos.top /**+ this.scrollOffset**/ /** OFFSET */
                    const squareWidth = this.currentSize.width*scale > this.maxSizes.width-this.currentPos.left ? this.maxSizes.width-this.currentPos.left: this.currentSize.width*scale
                    const squareHeight = this.currentSize.height*scale >this.maxSizes.height - this.currentPos.top? this.maxSizes.height-this.currentPos.top : this.currentSize.height*scale/**+ this.scrollOffset**/ /** OFFSET */
                    this.square.transitionTo({ width: squareWidth < 40 ? 40 : squareWidth , height: squareHeight < 534 ? 534 : squareHeight }, 0)
                }
            },
            onPanResponderTerminationRequest: () => true,
            onPanResponderRelease: () => {
                this.scrollView.setNativeProps({ scrollEnabled: true })
                this.isResizing = false
            // The user has released all touches while this view is the
            // responder. This typically means a gesture has succeeded
            },
            onPanResponderTerminate: () => {
            // Another component has become the responder, so this gesture
            // should be cancelled
            },
            onShouldBlockNativeResponder: () => true
            ,
        })
    }

    onToggleModal = () => {
        const { onToggleModal } = this.props
        onToggleModal()
        this.setState({ cropMode: false })
    }

    onCropImage = () => {
        let imgWidth
        let imgHeight
        // const { photo } = this.props
        const { uri } = this.state
        Image.getSize(uri, (width2, height2) => {
            imgWidth = width2
            imgHeight = height2
            const heightRatio = this.currentSize.height / this.maxSizes.height
            const offsetHeightRatio = this.currentPos.top / this.maxSizes.height

            const isOutOfBoundsY = imgHeight < (imgHeight * heightRatio) + imgHeight * offsetHeightRatio
            const offsetMaxHeight = (imgHeight * heightRatio + imgHeight * offsetHeightRatio) - imgHeight

            const isOutOfBoundsX = imgWidth < (this.currentPos.left * imgWidth / width) + (this.currentSize.width * imgWidth / width)
            const offsetMaxWidth = (this.currentPos.left * imgWidth / width) + (this.currentSize.width * imgWidth / width) - imgWidth

            const isOutOfBoundsLeft = (this.currentPos.left * imgWidth / width) < 0
            const isOutOfBoundsTop = (imgHeight * offsetHeightRatio) < 0

            const originX = isOutOfBoundsLeft ? 0 : this.currentPos.left * imgWidth / width
            const originY = isOutOfBoundsTop ? 0 : imgHeight * offsetHeightRatio
            let cropWidth = this.currentSize.width * imgWidth / width
            let cropHeight = imgHeight * heightRatio

            if (isOutOfBoundsX) {
                cropWidth -= offsetMaxWidth
            }
            if (isOutOfBoundsY) {
                cropHeight -= offsetMaxHeight
            }
            if (isOutOfBoundsLeft) {
                cropWidth += this.currentPos.left * imgWidth / width
            }
            if (isOutOfBoundsTop) {
                cropHeight += imgHeight * offsetHeightRatio
            }

            const cropObj = {
                originX,
                originY,
                width: cropWidth,
                height: cropHeight,
            }
            FileSystem.downloadAsync(
                uri,
                FileSystem.documentDirectory + 'image',
            ).then((localFile) => {
                if (cropObj.height > 0 && cropObj.width > 0) {
                    ImageManipulator.manipulateAsync(
                        localFile.uri,
                        [{
                            crop: cropObj,
                        }],
                        //MAYBE NEED TO BE JPG
                        { format: 'jpg' },
                    ).then((manipResult) => {
                        this.setState({ uri: manipResult.uri, cropMode: false })
                    }).catch(error => console.log(error))
                }
            }).catch(error => console.log(error))
            
        })
        this.setState({ cropMode: false })
    }

    onRotateImage = () => {
        // const { onPictureChoosed } = this.props
        const { uri } = this.state
        FileSystem.downloadAsync(
            uri,
            FileSystem.documentDirectory + 'image',
        ).then((localFile) => {
            Image.getSize(localFile.uri, (width2, height2) => {
                ImageManipulator.manipulateAsync(uri, [{
                    rotate: -90,
                }, {
                    resize: {
                        width: height2,
                        height: width2,
                    },
                }], {
                    compress: 1,
                }).then((rotPhoto) => {
                    // onPictureChoosed(rotPhoto.uri)
                    this.setState({ uri: rotPhoto.uri })
                })
            })
        })
        
    }

    onHandleScroll = (event) => {
        this.scrollOffset = event.nativeEvent.contentOffset.y
    }

    renderButtom = (title, action, icon) => (
        <HybridTouch onPress={action}>
            <View style={{ padding: 10, flexDirection: 'row', alignItems: 'center' }}>
                <Icon size={20} name={icon} color="white" />
                <Text style={{ color: 'white', fontSize: 15, marginLeft: 5 }}>{title}</Text>
            </View>
        </HybridTouch>
    )

    render() {
        const { isVisible, onPictureChoosed } = this.props
        const {
            uri, cropMode,
        } = this.state
        return (
            <Modal
                animationType="slide"
                transparent={false}
                visible={isVisible}
                hardwareAccelerated
                onRequestClose={() => {
                    this.onToggleModal()
                    console.log('Modal has been closed.')
                }}
            >
                <SafeAreaView
                    style={{
                        width, backgroundColor: 'rgba(0,0,0,0.7)', flexDirection: 'row', justifyContent: 'space-between',
                    }}
                >
                    {this.renderButtom('', this.onToggleModal, 'arrow-left')}
                    {
                        !cropMode
                            ? (
                                <View style={{ flexDirection: 'row' }}>
                                    {this.renderButtom('Crop', () => {
                                        this.setState({ cropMode: true })
                                    }, 'crop')}
                                    {this.renderButtom('Rotate', this.onRotateImage, 'rotate-left')}
                                    {this.renderButtom('Done', () => {
                                        onPictureChoosed(uri)
                                        this.onToggleModal()
                                    }, 'check')}
                                </View>
                            )
                            : this.renderButtom('Done', this.onCropImage, 'check')
                    }
                </SafeAreaView>
                {/* changed here so that image does not start from below the safeview */}
                <View style={{ flex: 1, backgroundColor: 'black',position:'absolute',x:0,y:0,zIndex:-1 }}>
                    <ScrollView
                        style={{ position: 'relative', flex: 1 }}
                        maximumZoomScale={1}
                        minimumZoomScale={1}
                        scrollEventThrottle={16}
                        onScroll={this.onHandleScroll}
                        bounces={false}
                        ref={(c) => { this.scrollView = c; }}
                    >
                        <Image
                            style={{ backgroundColor: 'black', width:width,height: height}}
                            source={{ uri:uri }}
                            resizeMode='contain'
                            onLayout={(event) => {
                                this.maxSizes.width = event.nativeEvent.layout.width || 100
                                this.maxSizes.height = event.nativeEvent.layout.height || 100
                            }}
                        />
                        {
                            !!cropMode
                        && (
                            <Animatable.View
                                onLayout={(event) => {
                                    this.currentSize.height = event.nativeEvent.layout.height
                                    this.currentSize.width = event.nativeEvent.layout.width
                                    this.currentPos.top = event.nativeEvent.layout.y
                                    this.currentPos.left = event.nativeEvent.layout.x
                                }}
                                ref={(ref) => { this.square = ref }}
                                {...this._panResponder.panHandlers}
                                style={{
                                    borderStyle: 'dashed',
                                    borderRadius: 2,
                                    borderWidth: 1,
                                    borderColor: 'pink',
                                    flex: 1,
                                    minHeight: 200,
                                    minWidth:10,
                                    width:this.maxSizes.height/(1.5*14)+2,
                                    //border width *2
                                    height:this.maxSizes.height/1.5+2,
                                    position: 'absolute',
                                    top:(this.maxSizes.height-this.maxSizes.height/(1.5)+2)/2,
                                    left:(this.maxSizes.width-this.maxSizes.height/(1.5*14)+2)/2,
                                    maxHeight: this.maxSizes.height,
                                    maxWidth: this.maxSizes.width,
                                    backgroundColor: 'rgba(255,255,255,0.5)',
                                }}
                            />
                        )
                        }
                    </ScrollView>
                </View>
            </Modal>
        )
    }
}

export default ImgManipulator


ImgManipulator.defaultProps = {
    onPictureChoosed: uri => console.log('URI:', uri),
}

ImgManipulator.propTypes = {
    isVisible: PropTypes.bool.isRequired,
    onPictureChoosed: PropTypes.func,
    photo: PropTypes.object.isRequired,
    onToggleModal: PropTypes.func.isRequired,
}
